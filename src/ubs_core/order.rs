//! Order types for UBSCore

use crate::fast_ulid::SnowflakeGenRng;
use crate::user_account::UserId;
use serde::{Deserialize, Serialize};

/// Order side
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
#[repr(u8)]
pub enum Side {
    Buy = 0,
    Sell = 1,
}

impl TryFrom<u8> for Side {
    type Error = ();

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(Side::Buy),
            1 => Ok(Side::Sell),
            _ => Err(()),
        }
    }
}

/// Order type
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
#[repr(u8)]
pub enum OrderType {
    Limit = 0,
    Market = 1,
}

impl TryFrom<u8> for OrderType {
    type Error = ();

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(OrderType::Limit),
            1 => Ok(OrderType::Market),
            _ => Err(()),
        }
    }
}

/// Internal order used by UBSCore
/// "Internal" prefix: trusted, from Gateway (already validated)
/// order_id is a u64 generated by SnowflakeGenRng:
///   - 44 bits: timestamp (ms)
///   - 7 bits: machine ID (128 machines)
///   - 13 bits: sequence (8192 IDs/ms)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InternalOrder {
    pub order_id: u64, // SnowflakeGenRng format
    pub user_id: UserId,
    pub symbol_id: u32,
    pub side: Side,
    pub price: u64, // Raw u64 (already scaled by Gateway)
    pub qty: u64,   // Raw u64 (already scaled by Gateway)
    pub order_type: OrderType,
}

impl InternalOrder {
    /// Get timestamp from order_id (using SnowflakeGen format)
    pub fn timestamp_ms(&self) -> u64 {
        SnowflakeGenRng::timestamp_ms(self.order_id)
    }

    /// Get machine ID from order_id
    pub fn machine_id(&self) -> u8 {
        SnowflakeGenRng::machine_id(self.order_id)
    }

    /// Calculate order cost (SECURITY: never trust Gateway's cost field)
    ///
    /// Uses checked_mul to detect overflow:
    /// - overflow → u64::MAX → order rejected later
    pub fn calculate_cost(&self) -> u64 {
        match self.side {
            // Buy: pay quote asset (price × qty)
            Side::Buy => self.price.checked_mul(self.qty).unwrap_or(u64::MAX),
            // Sell: pay base asset (qty)
            Side::Sell => self.qty,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_order(side: Side, price: u64, qty: u64) -> InternalOrder {
        // Create order_id: ts=1000, machine_id=1, seq=0
        let order_id = SnowflakeGenRng::from_parts(1000, 1, 0);
        InternalOrder {
            order_id,
            user_id: 1,
            symbol_id: 1,
            side,
            price,
            qty,
            order_type: OrderType::Limit,
        }
    }

    #[test]
    fn test_buy_cost_normal() {
        let order = make_order(Side::Buy, 100, 5);
        assert_eq!(order.calculate_cost(), 500);
    }

    #[test]
    fn test_buy_cost_overflow() {
        let order = make_order(Side::Buy, u64::MAX, 2);
        assert_eq!(order.calculate_cost(), u64::MAX);
    }

    #[test]
    fn test_sell_cost() {
        let order = make_order(Side::Sell, 100, 5);
        assert_eq!(order.calculate_cost(), 5); // qty only
    }

    #[test]
    fn test_timestamp_extraction() {
        let order = make_order(Side::Buy, 100, 5);
        assert_eq!(order.timestamp_ms(), 1000);
    }

    #[test]
    fn test_machine_id_extraction() {
        let order = make_order(Side::Buy, 100, 5);
        assert_eq!(order.machine_id(), 1);
    }
}

/// Cancel order request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelRequest {
    pub user_id: UserId,
    pub order_id: u64,
}
